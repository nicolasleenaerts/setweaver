vertex_label_color = "black",
edge_color = "darkgrey",
edge_label_color = "black",
min_arrow_width = 1,
max_arrow_width = 10,
node_size = 40,
label_cex = 0.8) {
# --- Input Validation ---
# Check if data is a dataframe
if (!base::inherits(data, "data.frame")) base::stop("Input 'data' must be a data frame.")
# Check if the outcome is a single string
if (!base::is.character(y_var) || base::length(y_var) != 1) base::stop("'y_var' must be a single string.")
# Allow x_vars to be empty for case with only Y
if (!base::is.character(x_vars) ) base::stop("'x_vars' must be a character vector.")
# Check if outcome is in the data
if (!y_var %in% base::names(data)) base::stop("'", y_var, "' not found in data frame.")
# Check if predictors are in the data
if (base::length(x_vars) > 0 && !base::all(x_vars %in% base::names(data))) {
missing_vars <- x_vars[!x_vars %in% base::names(data)]
base::stop("Following 'x_vars' not found in data frame: ", base::paste(missing_vars, collapse=", "))
}
#  Check if the labels for the variables are a names vector or list or NULL
if (!base::is.null(var_labels) && !base::is.list(var_labels) && !base::is.vector(var_labels)) {
base::stop("'var_labels' must be a named vector or list, or NULL.")
}
#Check if the labels for the variables are a names vector or list
if (!base::is.null(var_labels) && base::is.null(names(var_labels))) {
base::stop("'var_labels' must be a *named* vector or list.")
}
# Check if variables are binary (or logical)
all_vars_to_check <- base::c(y_var, x_vars)
# Check whether the outcome is binary Y var
if (!check_binary(data,y_var)) base::stop("Y variable '", y_var, "' must be binary (0/1 or TRUE/FALSE). Found values: ", base::paste(utils::head(base::unique(data[[y_var]])), collapse=", "))
# Check whether X vars are binary only if they exist
if (base::length(x_vars) > 0) {
non_binary_x <- x_vars[!base::sapply(x_vars, function(x){check_binary(data,x)})]
if (base::length(non_binary_x) > 0) {
non_binary_vals <- base::sapply(non_binary_x, function(v) base::paste(utils::head(base::unique(data[[v]])), collapse=","))
stop("X variables must be binary (0/1 or TRUE/FALSE). Non-binary found: ",
base::paste(base::paste0(non_binary_x, " (values: ", non_binary_vals, ")"), collapse="; "))
}
}
# --- Calculate Conditional Probabilities ---
if (method=='conditional'){
# Ensure data is numeric 0/1 for calculations
selected_data = data %>%
dplyr::select(dplyr::all_of(all_vars_to_check)) %>%
dplyr::mutate(dplyr::across(dplyr::everything(), base::as.numeric))
# Conditional Probabilities P(Y=1 | Xi=1)
cond_probs <- base::list()
if(base::length(x_vars) > 0) {
for (x_var in x_vars) {
# Subset data where Xi=1
subset_data <- selected_data %>% dplyr::filter(.data[[x_var]] == 1)
if (base::nrow(subset_data) > 0) {
# Calculate P(Y=1) within the subset
cond_probs[[x_var]] <- base::mean(subset_data[[y_var]], na.rm = TRUE)
} else {
# Handle case where Xi never occurs (P(Xi)=0)
cond_probs[[x_var]] <- NA # Keep as NA for now
warning("Variable '", x_var, "' has no occurrences (P(", x_var, ")=0). Conditional probability P(Y|", x_var, ") set to NA.")
}
}
}
probs <- base::unlist(cond_probs)
}
# --- Perform Logistic Regression ---
if (method=='logistic'){
# Select data and ensure numeric 0/1
selected_data <- data %>%
dplyr::select(dplyr::all_of(all_vars_to_check)) %>%
dplyr::mutate(dplyr::across(dplyr::everything(), as.numeric)) %>%
stats::na.omit() # IMPORTANT: Remove rows with NAs for GLM
if(nrow(selected_data) < 2) {
stop("Insufficient non-NA data (need at least 2 rows) to fit logistic regression.")
}
# Check for variance after removing NA
if (length(unique(selected_data[[y_var]])) < 2) {
stop("Outcome variable '", y_var,"' has no variance after removing NAs. Cannot fit model.")
}
no_variance_x <- x_vars[sapply(x_vars, function(v) length(unique(selected_data[[v]])) < 2)]
if (length(no_variance_x) > 0) {
warning("Predictor variable(s) have no variance after removing NAs: ", paste(no_variance_x, collapse=", "), ". They will be excluded from the model.")
x_vars <- setdiff(x_vars, no_variance_x) # Remove them
if (length(x_vars) == 0) {
stop("No predictor variables with variance remaining after removing NAs.")
}
}
formula_str <- paste(y_var, "~", paste(x_vars, collapse = " + "))
logit_model <- tryCatch({
stats::glm(stats::as.formula(formula_str), data = selected_data, family = stats::binomial(link = "logit"))
}, error = function(e) {
stop("Error fitting logistic regression model: ", e$message)
})
model_summary <- summary(logit_model)
raw_coeffs <- stats::coefficients(model_summary) # Matrix with Estimate, Std. Error etc.
# --- Extract Coefficients and Calculate Effect Probabilities ---
logit_coeffs_est <- numeric(length(x_vars))
names(logit_coeffs_est) <- x_vars
missing_coeffs_vars <- character()
for(x_var in x_vars) {
if (x_var %in% rownames(raw_coeffs)) {
# Handle potential NA coefficients (e.g., perfect separation/collinearity)
if (is.na(raw_coeffs[x_var, "Estimate"])) {
warning("Coefficient for '", x_var, "' is NA (possibly due to collinearity or separation). Setting effect probability to 0.5.")
logit_coeffs_est[x_var] <- 0 # Treat as no effect if NA
} else {
logit_coeffs_est[x_var] <- raw_coeffs[x_var, "Estimate"]
}
} else {
# Should not happen if variable had variance, but check anyway
warning("Coefficient for '", x_var, "' not found in model summary (unexpected). Setting effect probability to 0.5.")
logit_coeffs_est[x_var] <- 0
missing_coeffs_vars <- c(missing_coeffs_vars, x_var)
}
}
# Inverse logit function
inv_logit <- function(x) { exp(x) / (1 + exp(x)) }
# Calculate effect probabilities from logit coefficients
probs <- inv_logit(logit_coeffs_est)
}
# --- Calculate Marginal Probabilities ---
# Using original data before NA removal for consistency
marg_data_selected <- data %>%
dplyr::select(dplyr::all_of(c(y_var, x_vars))) %>% # Select original x_vars (incl. those removed)
dplyr::mutate(dplyr::across(dplyr::everything(), as.numeric))
# Marginal Probabilities
marginal_probs = selected_data %>%
dplyr::summarise(dplyr::across(dplyr::everything(), ~ base::mean(.x, na.rm = TRUE)))
p_y = marginal_probs[[y_var]]
# Handle case where there are no x_vars
p_x = if(base::length(x_vars) > 0) {
marginal_probs %>% dplyr::select(dplyr::all_of(x_vars))
} else {
base::numeric(0) # Empty numeric vector
}
# --- Prepare for igraph ---
# Node Information
node_names <- base::c(y_var, x_vars)
# Ensure marginal probabilities align with node_names (handle removed vars)
marg_p_values_ordered <- numeric(length(node_names))
names(marg_p_values_ordered) <- node_names
marg_p_values_ordered[y_var] <- p_y
for(xn in x_vars){
if(xn %in% names(p_x)){
marg_p_values_ordered[xn] <- p_x[[xn]]
} else {
marg_p_values_ordered[xn] <- NA # Should not happen if selected correctly
}
}
# Handle potential NAs if a variable was all NA originally
marg_p_values_ordered[is.na(marg_p_values_ordered)] <- 0
marg_p_values <- marg_p_values_ordered
# Use sapply to apply the function to all node_names
display_names <- base::sapply(node_names, function(x){get_display_name(var_labels,x)}, USE.NAMES = FALSE)
# Create node labels using display names and formatted probabilities
node_labels <- base::sprintf("P(%s)\n%.*f", display_names, prob_digits, marg_p_values)
nodes <- base::data.frame(
name = node_names, # Internal name for igraph structure
label = node_labels, # Visual label for the plot
stringsAsFactors = FALSE
)
# Edge Information (only for x_vars included in the final model)
valid_x_vars <- names(probs) # These are the vars with calculated effect probs
# Edge Information
if (length(x_vars) > 0) {
edges <- base::data.frame(
from = x_vars,
to = y_var,
probs = probs,
# Format edge labels using prob_digits
label = base::sprintf("%.*f", prob_digits, probs),
stringsAsFactors = FALSE
)
# Handle cases where P(Xi)=0 resulted in NA probs for label
edges$label[base::is.na(edges$probs)] <- "NA"
# Scale probability to arrow width
if (method == 'conditional'){
strength <- edges$probs[!base::is.na(edges$probs)]
lower_bound <- if(base::length(strength) > 0) base::min(strength) else 0
upper_bound <- if(base::length(strength) > 0) base::max(strength) else 0
}
if (method == 'logistic'){
strength <- abs(edges$probs - 0.5)
lower_bound <- min(strength, na.rm = TRUE)
upper_bound <- max(strength, na.rm = TRUE)
}
if (length(strength) == 0 || upper_bound == lower_bound) {
# Assign average width if all effects are the same strength or only one edge
edges$width <- (min_arrow_width + max_arrow_width) / 2
} else if (upper_bound > lower_bound) {
# Scale effect strength linearly to width range
edges$width <- min_arrow_width + (strength - lower_bound) / (upper_bound - lower_bound) * (max_arrow_width - min_arrow_width)
} else {
# Fallback (should not happen with valid strength values)
edges$width <- min_arrow_width
}
# Ensure NAs (shouldn't exist here) get minimum width
edges$width[is.na(edges$width)] <- min_arrow_width
} else {
# No valid X variables remained for the model
edges <- data.frame(from=character(), to=character(), effect_prob=numeric(), label=character(), width=numeric(), stringsAsFactors = FALSE)
warning("No predictors remained in the model to draw edges.")
}
# --- Create and Plot Graph ---
# Nodes dataframe might contain nodes for x_vars that were removed from model
# graph_from_data_frame handles this; only nodes connected by edges or listed in 'vertices' are added.
# We pass the full 'nodes' df to ensure all original vars appear, even if disconnected.
g <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = TRUE)
# Set layout
l <- NULL # Initialize layout variable
if (igraph::vcount(g) > 0) {
if (y_var %in% igraph::V(g)$name && base::length(x_vars) > 0) { # Ensure Y is center only if there are X's
center_node_index <- which(igraph::V(g)$name == y_var)
if (length(center_node_index) > 0) {
l <- igraph::layout_as_star(g, center = center_node_index)
} else {
warning("Y variable '", y_var, "' specified but not found as a vertex. Using default layout.")
l <- igraph::layout_nicely(g)
}
} else { # If only Y node, or Y not found, or graph disconnected
l <- igraph::layout_nicely(g) # Nicely usually works well for single nodes or disconnected graphs
}
} else {
# Handle empty graph case (no nodes/edges) - create dummy layout
l <- base::matrix(base::numeric(0), ncol=2)
warning("Graph is empty (no nodes or edges). Nothing to plot.")
}
# Set title
if (is.null(title)==T){
if (method=='conditional'){title="Conditional Probability Network"}
if (method=='logistic'){title="Logistic Regression Effect Probability Network"}
}
# Only plot if the graph is not empty
if (igraph::vcount(g) > 0) {
# Ensure layout is valid before plotting
if (base::is.null(l) || !base::is.matrix(l) || base::nrow(l) != igraph::vcount(g)) {
warning("Layout calculation failed. Attempting default layout.")
l <- igraph::layout_nicely(g) # Fallback layout
}
plot(g,
layout = l,
main = title,
vertex.shape = "circle",
vertex.size = node_size,
vertex.color = vertex_color,
vertex.frame.color = NA,
vertex.label = igraph::V(g)$label,
vertex.label.color = vertex_label_color,
vertex.label.cex = label_cex,
edge.color = edge_color,
# Only set edge attributes if edges exist
edge.width = if(igraph::ecount(g) > 0) igraph::E(g)$width else NULL,
edge.label = if(igraph::ecount(g) > 0) igraph::E(g)$label else NULL,
edge.label.color = edge_label_color,
edge.label.cex = label_cex,
edge.arrow.size = 0,
edge.curved = 0.1
)
} else {
# Create a blank plot with title if graph is empty
plot(NULL, xlim=c(-1,1), ylim=c(-1,1), main=paste(title, "(Empty Graph)"), xlab="", ylab="", axes=FALSE)
graphics::text(0, 0, "No data to display", cex=1.2)
}
# Return the graph object invisibly
base::invisible(g)
}
get_display_name <- function(var_labels, name) {
# Generate display names based on var_labels if provided
# Check if var_labels is provided and the name exists within it
if (!base::is.null(var_labels) && !base::is.null(names(var_labels)) && name %in% base::names(var_labels)) {
# Return the corresponding label value
return(var_labels[[name]])
} else {
# If var_labels *was* provided but the name wasn't found, issue a warning
if (!base::is.null(var_labels) && !base::is.null(names(var_labels)) && !(name %in% base::names(var_labels))) {
warning("Label not found for variable '", name, "' in 'var_labels'. Using original name.")
}
# Default to original name if var_labels is NULL or name not found
return(name)
}
}
check_binary <- function(data,col_name) {
vals <- tryCatch(base::unique(stats::na.omit(data[[col_name]])), error = function(e) NULL)
if (base::is.null(vals)) return(FALSE) # Column likely didn't exist or had only NAs
# Allow empty vectors (e.g. if X never occurs and has only NAs)
if (base::length(vals) == 0) return(TRUE)
base::is.logical(vals) || (base::is.numeric(vals) && base::all(vals %in% c(0, 1)))
}
plot_cprob(misimdata,'y',colnames(misimdata[,3:6]),method = 'conditional')
plot_cprob(misimdata,'y',colnames(misimdata[,3:6]),method = 'conditional',vertex_color= 'red')
plot_cprob(misimdata,'y',colnames(misimdata[,3:6]),method = 'conditional',vertex_color= 'red',edge_color='pink' )
check()
devtools::document()
check()
devtools::document()
options(buildtools.check = function(action) TRUE )
check()
?setdiff
?exp
results_probstat <- probstat(misimdata$y,pairmiresult$expanded.data,nfolds=5)
pairmiresult = pairmi(misimdata[,2:6])
results_probstat <- probstat(misimdata$y,pairmiresult$expanded.data,nfolds=5)
load_all(0)
load_all()
v
pairmiresult = pairmi(misimdata[,2:6])
results_probstat <- probstat(misimdata$y,pairmiresult$expanded.data,nfolds=5)
find_minimal_sets(results_probstat$xvars[results_probstat$cprob >= 0.70])
?find_minimal_sets(results_probstat$xvars[results_probstat$cprob >= 0.70])
?find_minimal_sets(results_probstat$xvars[results_probstat$cprob >= 0.70])
?progress_bR
?progress_bAR
?progress_bar
??progress_bar
loas_all()
load_all()
find_minimal_sets(results_probstat$xvars[results_probstat$cprob >= 0.70])
results_probstat$xvars
results_probstat$
results_probstat
v
find_minimal_sets(results_probstat$xvars[results_probstat$cprob >= 0.10])
find_minimal_sets(results_probstat$xvars[results_probstat$cprob >= 0.20])
load_all()
find_minimal_sets(results_probstat$xvars[results_probstat$cprob >= 0.20])
str_vec=results_probstat$xvars[results_probstat$cprob >= 0.20]
str_vec
minimal_sets <- character(0)
i=1
i=2
set1 <- string_to_set(str_vec[i])
set1
j=5
set2 <- string_to_set(str_vec[j])
set2
all(set2 %in% set1)
# Function to convert strings to sets
string_to_set <- function(string) {
# Remove underscores
string <- gsub("_", "", string)
# Replace 's' with space followed by the character
modified_string <- gsub("([s])", " \\1", string)
unlist(strsplit(modified_string, " "))
}
# Function to check if one set is nested in another
is_nested <- function(set1, set2) {
all(set1 %in% set2)
}
# Function to convert strings to sets
string_to_set <- function(string) {
# Remove underscores
string <- gsub("_", "", string)
# Replace 's' with space followed by the character
modified_string <- gsub("([s])", " \\1", string)
unlist(strsplit(modified_string, " "))
}
# Function to check if one set is nested in another
is_nested <- function(set1, set2) {
all(set1 %in% set2)
}
minimal_sets <- character(0)
set1 <- string_to_set(str_vec[i])
minimal <- TRUE
for (j in 1:length(str_vec)) {
if (i != j) {
set2 <- string_to_set(str_vec[j])
if (is_nested(set2, set1)) {
minimal <- FALSE
break
}
}
}
# Function to identify minimally sufficient sets with a progress bar
find_minimal_sets <- function(str_vec) {
minimal_sets <- character(0)
# Initialize the progress bar
pb <- progress_bar$new(
format = "  [:bar] :percent :elapsed",
total = length(str_vec),
width = 60
)
for (i in 1:length(str_vec)) {
set1 <- string_to_set(str_vec[i])
minimal <- TRUE
for (j in 1:length(str_vec)) {
if (i != j) {
set2 <- string_to_set(str_vec[j])
if (is_nested(set2, set1)) {
minimal <- FALSE
break
}
}
}
if (minimal) {
minimal_sets <- c(minimal_sets, str_vec[i])
}
# Update the progress bar
pb$tick()
}
return(minimal_sets)
}
find_minimal_sets(results_probstat$xvars[results_probstat$cprob >= 0.20])
lbrary(progress)
library(progress)
find_minimal_sets(results_probstat$xvars[results_probstat$cprob >= 0.20])
load_all()
# Identify minimally sufficient sets
# Function to convert strings to sets
string_to_set <- function(string) {
# Remove underscores
string <- gsub("_", "", string)
# Replace 's' with space followed by the character
modified_string <- gsub("([s])", " \\1", string)
unlist(strsplit(modified_string, " "))
}
# Function to check if one set is nested in another
is_nested <- function(set1, set2) {
all(set1 %in% set2)
}
# Function to identify minimally sufficient sets with a progress bar
find_minimal_sets <- function(str_vec) {
minimal_sets <- character(0)
# Initialize the progress bar
pb <- progress_bar$new(
format = "  [:bar] :percent :elapsed",
total = length(str_vec),
width = 60
)
for (i in 1:length(str_vec)) {
set1 <- string_to_set(str_vec[i])
minimal <- TRUE
for (j in 1:length(str_vec)) {
if (i != j) {
set2 <- string_to_set(str_vec[j])
if (is_nested(set2, set1)) {
minimal <- FALSE
break
}
}
}
if (minimal) {
minimal_sets <- c(minimal_sets, str_vec[i])
}
# Update the progress bar
pb$tick()
}
return(minimal_sets)
}
# Conditional probability of lifetime diagnosis on symptom sets
mdd_life <- probstat_adapted_1(mdd$dsm_mde, mdd[, 21:531], nfolds = 10)
pairmiresult = pairmi(misimdata[,2:6])
results_probstat <- probstat(misimdata$y,pairmiresult$expanded.data,nfolds=5)
find_minimal_sets(results_probstat$xvars[results_probstat$cprob >= 0.20])
save.image("~/Postdoc_KUL/Analyses_Researcher_KUL/Mutual_Information/Minimally_Sufficient_Data.RData")
use_citation()
usethis::use_tidy_description()
search()
devtools::document()
pkgload::dev_help('find_minimal_sets')
yesno::
usethis::use_tidy_description()
devtools::document()
load_all()
load_all()
check_binary()
devtools::document()
devtools::document()
`rm(list = c("find_minimal_sets"))`
rm(list = c("find_minimal_sets"))
devtools::document()
browseVignettes()
usethis::use_release_issue()
usethis::use_testthat(3)
use_test("probstat")
pairmi(misimdata[,2:6])
?expect_equal
test_that("probstat works", {
expect_equal(probstat(misimdata$y,pairmiresult$expanded.data,nfolds=5), 4)
})
test_that("probstat works", {
expect_equal(probstat(misimdata$y,pairmiresult$expanded.data,nfolds=5), 4)
})
pairmiresult=pairmi(misimdata[,2:6])
# Run probstat
probstatresult = probstat(misimdata$y,pairmiresult$expanded.data)
?complete.cases
saveRDS(pairmiresult, file = "pairmiresult.rds")
getwd()
saveRDS(probstatresult, file = "probstatresult.rds")
probstatresult = probstat(misimdata$y,pairmiresult$expanded.data,nfolds = 5)
saveRDS(probstatresult, file = "probstatresult.rds")
pairmiresult$expanded.data
check()
check()
check()
test()
test()
test()
?pairmi
?plot_prob
?pairmi
?plot_prob
load_all()
?plot_prob
?plot_prob
load_all()
?plot_prob
?proobstat
?probstat
document()
?plot_prob
