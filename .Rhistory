nrow(gad) # 1,948
nrow(com) # 3,129
3129 - 2285 # 844 MDD only
3129 - 1948 # 1,181 GAD only
(2285 + 1948) - 3129 # 1,104 overlapping cases
# Assume zeros for missing cases (skip outs = absence)
com[is.na(com[,])] <- 0
# Adding:
# lifetime diagnosis (and/or)
# moderate distress (and/or)
# severe distress (and/or)
com$life <- ifelse(com$dsm_mde == 1 | com$dsm_gad == 1, 1, 0)
com$mod <- ifelse(com$mddmod == 1 | com$gadmod == 1, 1, 0)
com$sev <- ifelse(com$mddsev == 1 | com$gadsev == 1, 1, 0)
# Proportions of sample with diagnoses
length(which(com$dsm_mde == 1)) # 1,826
1826/3129 # 0.58
length(which(com$dsm_gad == 1)) # 752
752/3129 # 0.24
# Proportions of sample with moderate distress
length(which(com$mddmod == 1)) # 2,127
2127/3129 # 0.68
length(which(com$gadmod == 1)) # 1,503
1503/3129 # 0.48
# Proportions of sample with severe distress
length(which(com$mddsev == 1)) # 1,300
1300/3129 # 0.42
length(which(com$gadsev == 1)) # 685
685/3129 # 0.22
# Encode symptoms into data set
com$s1 <- com$d24a
com$s2 <- com$d24e
com$s3 <- ifelse(com$d26a == 1 | com$d26b == 1 | com$d26c == 1 | com$d26e == 1, 1, 0)
com$s4 <- ifelse(com$d26g == 1 | com$g9f == 1, 1, 0)
com$s5 <- ifelse(com$d26l == 1 | com$d26n == 1 | com$g9a == 1, 1, 0)
com$s6 <- ifelse(com$d26j == 1 | com$g9b == 1, 1, 0)
com$s7 <- ifelse(com$d26v == 1 | com$d26w == 1, 1, 0)
com$s8 <- ifelse(com$d26r == 1 | com$g9d == 1, 1, 0)
com$s9 <- ifelse(com$d26aa == 1 | com$d26bb == 1, 1, 0)
com$s10 <- com$g3
com$s11 <- com$g4
com$s12 <- com$g9c
com$s13 <- com$g9e
describe(com)
# Create all combinations of the 18 elements
com_combos <- do.call(c, lapply(1:13, function(x) combn(colnames(com[,36:48]), x, simplify = FALSE)))
# Total number of symptom combinations (excluding empty set)
length(com_combos)
# Create new variables in the data frame based on symptom combinations
for (comb in com_combos) {
var_name <- paste(comb, collapse = "_")
com[[var_name]] <- ifelse(rowSums(com[comb] == 1) == length(comb), 1, 0)
}
# Conditional probability of lifetime diagnosis on symptom sets
com_life <- probstat_adapted(com$life, com[, 36:8226], nfolds = 10)
# Conditional probability of lifetime diagnosis on symptom sets
com_life <- probstat(com$life, com[, 36:8226], nfolds = 10)
# Function to convert strings to sets
string_to_set <- function(string) {
# Remove underscores
string <- gsub("_", "", string)
# Replace 's' with space followed by the character
modified_string <- gsub("([s])", " \\1", string)
unlist(strsplit(modified_string, " "))
}
# Function to check if one set is nested in another
is_nested <- function(set1, set2) {
all(set1 %in% set2)
}
# Function to identify minimally sufficient sets with a progress bar
find_minimal_sets <- function(str_vec) {
minimal_sets <- character(0)
# Initialize the progress bar
pb <- progress_bar$new(
format = "  [:bar] :percent :elapsed",
total = length(str_vec),
width = 60
)
for (i in 1:length(str_vec)) {
set1 <- string_to_set(str_vec[i])
minimal <- TRUE
for (j in 1:length(str_vec)) {
if (i != j) {
set2 <- string_to_set(str_vec[j])
if (is_nested(set2, set1)) {
minimal <- FALSE
break
}
}
}
if (minimal) {
minimal_sets <- c(minimal_sets, str_vec[i])
}
# Update the progress bar
pb$tick()
}
return(minimal_sets)
}
# Apply minimally sufficient function to vectors of strings
min_life95 <- find_minimal_sets(com_life$xvars[com_life$cprob >= 0.95])
min_life95
find_minimal_sets <- function(str_vec,sep='_') {
# Remove sets of which parts can be explained by an entire other set
str_vec[!apply(
# For every set
sapply(c(1:length(str_vec)),function(i){
# Again for every set
sapply(c(1:length(str_vec)),function(j){
# Only perform it if the sets are not the same
if (i!=j){
# Checks whether all parts of one vector are in another vector
all(strsplit(str_vec[i],split= sep)[[1]] %in% strsplit(str_vec[j],split= sep)[[1]])
} else {FALSE} # Is sets are the same, just output FALSE
})
}),1,any)]
}
min_life95_2 <- find_minimal_sets(com_life$xvars[com_life$cprob >= 0.95])
str_vec=com_life$xvars[com_life$cprob >= 0.95]
str_vec
str_vec=com_life$xvars[com_life$cprob >= 0.95]
min_life95_2 <- find_minimal_sets(com_life$xvars[com_life$cprob >= 0.95])
str_vec
# For every set
sapply(c(1:length(str_vec)),function(i){
# Again for every set
for (j in 1:length(str_vec)) {
if (i != j) {
minimal <- all(strsplit(str_vec[i],split= sep)[[1]] %in% strsplit(str_vec[j],split= sep)[[1]])
if (minimal==F) {break}
}
}
return(minimal)
})
sep='_'
# For every set
sapply(c(1:length(str_vec)),function(i){
# Again for every set
for (j in 1:length(str_vec)) {
if (i != j) {
minimal <- all(strsplit(str_vec[i],split= sep)[[1]] %in% strsplit(str_vec[j],split= sep)[[1]])
if (minimal==F) {break}
}
}
return(minimal)
})
# Remove sets of which parts can be explained by an entire other set
str_vec[# For every set
sapply(c(1:length(str_vec)),function(i){
# Again for every set
for (j in 1:length(str_vec)) {
if (i != j) {
minimal <- all(strsplit(str_vec[i],split= sep)[[1]] %in% strsplit(str_vec[j],split= sep)[[1]])
if (minimal==F) {break}
}
}
return(minimal)
})]
# Remove sets of which parts can be explained by an entire other set
str_vec[!apply(
# For every set
sapply(c(1:length(str_vec)),function(i){
# Again for every set
sapply(c(1:length(str_vec)),function(j){
# Only perform it if the sets are not the same
if (i!=j){
# Checks whether all parts of one vector are in another vector
all(strsplit(str_vec[i],split= sep)[[1]] %in% strsplit(str_vec[j],split= sep)[[1]])
} else {FALSE} # Is sets are the same, just output FALSE
})
}),1,any)]
# Remove sets of which parts can be explained by an entire other set
str_vec[!
# For every set
sapply(c(1:length(str_vec)),function(i){
# Again for every set
for (j in 1:length(str_vec)) {
if (i != j) {
minimal <- all(strsplit(str_vec[i],split= sep)[[1]] %in% strsplit(str_vec[j],split= sep)[[1]])
if (minimal==F) {break}
}
}
return(minimal)
})]
# For every set
sapply(c(1:length(str_vec)),function(i){
# Again for every set
for (j in 1:length(str_vec)) {
if (i != j) {
minimal <- all(strsplit(str_vec[i],split= sep)[[1]] %in% strsplit(str_vec[j],split= sep)[[1]])
if (minimal==T) {break}
}
}
return(minimal)
})
str_vec[1]
# Again for every set
for (j in 1:length(str_vec)) {
if (i != j) {
minimal <- all(strsplit(str_vec[j],split= sep)[[1]] %in% strsplit(str_vec[i],split= sep)[[1]])
if (minimal==T) {break}
}
}
minimal
str_vec[j]
str_vec
str_vec[i]
str_vec[j]
str_vec = results_probstat$xvars[results_probstat$cprob >= 0.20]
str_vec = results_probstat$xvars[results_probstat$cprob >= 0.10]
pairmiresult = pairmi(misimdata[,2:6])
results_probstat <- probstat(misimdata$y,pairmiresult$expanded.data,nfolds=5)
results_probstat$xvars[results_probstat$cprob >= 0.20]
results_probstat$xvars[results_probstat$cprob >= 0.10]
strings = c("x1_x2","x4_x5","x2_x3","x3_x4",x3_x5","x3_x4_x5")
strings = c("x1_x2","x4_x5","x2_x3","x3_x4","x3_x5","x3_x4_x5")
str_vec=strings
# For every set
sapply(c(1:length(str_vec)),function(i){
# Again for every set
for (j in 1:length(str_vec)) {
if (i != j) {
minimal <- all(strsplit(str_vec[j],split= sep)[[1]] %in% strsplit(str_vec[i],split= sep)[[1]])
if (minimal==T) {break}
}
}
return(minimal)
})
# For every set
sapply(c(1:length(str_vec)),function(i){
# Again for every set
for (j in 1:length(str_vec)) {
if (i != j) {
minimal <- all(strsplit(str_vec[i],split= sep)[[1]] %in% strsplit(str_vec[j],split= sep)[[1]])
if (minimal==T) {break}
}
}
return(minimal)
})
# For every set
sapply(c(1:length(str_vec)),function(i){
# Again for every set
for (j in 1:length(str_vec)) {
if (i != j) {
minimal <- all(strsplit(str_vec[j],split= sep)[[1]] %in% strsplit(str_vec[i],split= sep)[[1]])
if (minimal==T) {break}
}
}
return(minimal)
})
# Remove sets of which parts can be explained by an entire other set
str_vec[!# For every set
sapply(c(1:length(str_vec)),function(i){
# Again for every set
for (j in 1:length(str_vec)) {
if (i != j) {
minimal <- all(strsplit(str_vec[j],split= sep)[[1]] %in% strsplit(str_vec[i],split= sep)[[1]])
if (minimal==T) {break}
}
}
return(minimal)
})]
# Function to identify minimally sufficient sets with a progress bar
find_minimal_sets <- function(str_vec) {
minimal_sets <- character(0)
# Initialize the progress bar
pb <- progress_bar$new(
format = "  [:bar] :percent :elapsed",
total = length(str_vec),
width = 60
)
for (i in 1:length(str_vec)) {
set1 <- string_to_set(str_vec[i])
minimal <- TRUE
for (j in 1:length(str_vec)) {
if (i != j) {
set2 <- string_to_set(str_vec[j])
if (is_nested(set2, set1)) {
minimal <- FALSE
break
}
}
}
if (minimal) {
minimal_sets <- c(minimal_sets, str_vec[i])
}
# Update the progress bar
pb$tick()
}
return(minimal_sets)
}
# Apply minimally sufficient function to vectors of strings
min_life95 <- find_minimal_sets(com_life$xvars[com_life$cprob >= 0.95])
find_minimal_sets <- function(str_vec,sep='_') {
# Remove sets of which parts can be explained by an entire other set
str_vec[!
# For every set
sapply(c(1:length(str_vec)),function(i){
# Again for every set
for (j in 1:length(str_vec)) {
if (i != j) {
minimal <- all(strsplit(str_vec[j],split= sep)[[1]] %in% strsplit(str_vec[i],split= sep)[[1]])
if (minimal==T) {break}
}
}
return(minimal)
})]
}
# Apply minimally sufficient function to vectors of strings
min_life95 <- find_minimal_sets(com_life$xvars[com_life$cprob >= 0.95])
v
min_life95
# Function to identify minimally sufficient sets with a progress bar
find_minimal_sets <- function(str_vec) {
minimal_sets <- character(0)
# Initialize the progress bar
pb <- progress_bar$new(
format = "  [:bar] :percent :elapsed",
total = length(str_vec),
width = 60
)
for (i in 1:length(str_vec)) {
set1 <- string_to_set(str_vec[i])
minimal <- TRUE
for (j in 1:length(str_vec)) {
if (i != j) {
set2 <- string_to_set(str_vec[j])
if (is_nested(set2, set1)) {
minimal <- FALSE
break
}
}
}
if (minimal) {
minimal_sets <- c(minimal_sets, str_vec[i])
}
# Update the progress bar
pb$tick()
}
return(minimal_sets)
}
# Apply minimally sufficient function to vectors of strings
min_life95 <- find_minimal_sets(com_life$xvars[com_life$cprob >= 0.95])
min_life95 <- find_minimal_sets(com_life$xvars[com_life$cprob >= 0.95])
min_life95
find_minimal_sets <- function(str_vec,sep='_') {
# Remove sets of which parts can be explained by an entire other set
str_vec[!
# For every set
sapply(c(1:length(str_vec)),function(i){
# Again for every set
for (j in 1:length(str_vec)) {
if (i != j) {
minimal <- all(strsplit(str_vec[j],split= sep)[[1]] %in% strsplit(str_vec[i],split= sep)[[1]])
if (minimal==T) {break}
}
}
return(minimal)
})]
}
min_life95 <- find_minimal_sets(com_life$xvars[com_life$cprob >= 0.95])
min_life95
check()
options(buildtools.check = function(action) TRUE )
check()
base::?all
?all
?sapply
#_______________________________________
#### 1. Library and functions ----
#_______________________________________
library(readxl)
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
# Author: Nicolas Leenaerts
# Title: Adapt Study Preprocessing
# Data: Adapt Study
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_______________________________________
#### 1. Library and functions ----
#_______________________________________
library(readxl)
library(openxlsx)
source('/Users/u0127988/Dropbox (Personal)/RL_For_Craving_Nicolas_Leenaerts/Code/R/Adapt_Study_Supporting_Functions.R')
#_______________________________________
#### 2. Load data ----
#_______________________________________
adapt_data <- read_xlsx('/Users/u0127988/Dropbox (Personal)/Obesity Goldstein/MRT Analysis 201215 Deidentified FINAL.xlsx')
codebook <- read_xlsx('/Users/u0127988/Dropbox (Personal)/Obesity Goldstein/Deidentified Codebook 8.19.25.xlsx')
#_______________________________________
#### 3. Preprocess data ----
#_______________________________________
# Convert yes/no to 1/0
adapt_data$event <- ifelse(adapt_data$event=='survey_missed',1,0)
adapt_data$lag_meals <- ifelse(adapt_data$lag_meals=='Yes',1,0)
adapt_data$HadLapseYN <- ifelse(adapt_data$HadLapseYN=='Yes',1,0)
adapt_data$lag_tired <- ifelse(adapt_data$lag_tired=='Yes',1,0)
adapt_data$lag_hungry <- ifelse(adapt_data$lag_hungry=='Yes',1,0)
adapt_data$lag_bored <- ifelse(adapt_data$lag_bored=='Yes',1,0)
adapt_data$lag_priority <- ifelse(adapt_data$lag_priority=='Yes',1,0)
adapt_data$lag_cravings <- ifelse(adapt_data$lag_cravings=='Yes',1,0)
adapt_data$lag_urge <- ifelse(adapt_data$lag_urge=='Yes',1,0)
adapt_data$lag_TV <- ifelse(adapt_data$lag_TV=='Yes',1,0)
adapt_data$lag_interpersonal <- ifelse(adapt_data$lag_interpersonal=='Yes',1,0)
adapt_data$lag_temptfood <- ifelse(adapt_data$lag_temptfood=='Yes',1,0)
adapt_data$lag_ad<- ifelse(adapt_data$lag_ad=='Yes',1,0)
adapt_data$lag_alcohol<- ifelse(adapt_data$lag_alcohol=='Yes',1,0)
# Get action probabilities
action_probs = data.frame(matrix(0L,ncol=6,nrow=nrow(adapt_data)))
colnames(action_probs)=c('No_Intervention','Risk_Alert','Regulate','Efficacy','Motivation','Education')
action_probs$No_Intervention[adapt_data$intervention_code==0]=1
action_probs$No_Intervention[is.na(adapt_data$intervention_code)==T&adapt_data$event==0]=1
action_probs$No_Intervention[is.na(adapt_data$condition)==F]=0.4
action_probs$Risk_Alert[is.na(adapt_data$condition)==F]=0.12
action_probs$Regulate[is.na(adapt_data$condition)==F]=0.12
action_probs$Efficacy[is.na(adapt_data$condition)==F]=0.12
action_probs$Motivation[is.na(adapt_data$condition)==F]=0.12
action_probs$Education[is.na(adapt_data$condition)==F]=0.12
# Recode intervention_code
adapt_data$condition[adapt_data$condition=='No_Intervention'] <- 0
adapt_data$condition[adapt_data$condition=='Risk_Alert'] <- 1
adapt_data$condition[adapt_data$condition=='Regulate'] <- 2
adapt_data$condition[adapt_data$condition=='Efficacy'] <- 3
adapt_data$condition[adapt_data$condition=='Motivation'] <- 4
adapt_data$condition[adapt_data$condition=='Education'] <- 5
adapt_data$condition[adapt_data$intervention_code==0] <- 0
adapt_data$condition[is.na(adapt_data$condition)==T] <- 0
# Fill in dietary lapse
adapt_data$HadLapseYN[adapt_data$lag_meals==0]<-0
# Hot encode categorical variables (Study Phase, Day of the week, socializing, condition)
# Change time to continuous variable
# Create a variable with the difference in BMI (positive so that the RL algo wants to maximize it)
adapt_data$bmi.diff = adapt_data$bmi.0 -  adapt_data$bmi.2
zprob(misimdata$x1)
load_all()
library(devtols)
library(devtools)
load_all()
zprob(misimdata$x1)
document()
document()
?probstat
document()
ce()
?ce
?ce
?entfuns
document()
?entfuns
check()
options(buildtools.check = function(action) TRUE )
check()
library(devtoools)
library(devtools)
load_all(0)
load_all()
usethis::use_vignette("my-vignette")
devtools::build_rmd("vignettes/setweaver.Rmd")
library(setweaver)
# Pairing variables
results = pairmi(misimdata[,2:11],alpha = 0.05,n_elements = 5)
# Evaluating the sets
evaluated_sets = probstat(misimdata$y,results$expanded.data[,results$sets$set],nfolds = 5)
plot_prob(results$expanded.data,'y',colnames(misimdata[,3:6]),method='logistic')
View(results$expanded.data)
plot_prob(cbind(misimdata[,1],results$expanded.data[,15:19]),'y',colnames(results$expanded.data[,15:19]),method='logistic')
View(results$expanded.data[,15:19])
plot_prob(cbind(misimdata[,1],results$expanded.data[,13:17]),'y',colnames(results$expanded.data[,13:17]),method='logistic')
View(misimdata[,1])
plot_prob(cbind(y=misimdata[,1],results$expanded.data[,13:17]),'y',colnames(results$expanded.data[,13:17]),method='logistic')
---
title: "setweaver"
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
?fig_chunk
?fig_chunk
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/setweaver.Rmd")
devtools::build_rmd("vignettes/README.Rmd")
devtools::build_rmd("README.Rmd")
devtools::build_readme()
usethis::use_cran_badge()
usethis::use_news_md()
check()
use_pkgdown()
use_pkgdown_github_pages()
usethis::gh_token_help()
use_pkgdown_github_pages()
Sys.setenv(GITHUB_TOKEN = "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")
use_pkgdown_github_pages()
usethis::gh_token_help()
